#ifndef PKT_GEN_H
#define PKT_GEN_H
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>

void *base_ptr_pkt_gen;

#define CRITICAL_FRAME_ETHER_TYPE 0x66ab

/* define packet header structure */
// In practice, the device only sends packets with vlan header
// If we send a packet without vlan header, its timestamp will be placed wrongly.
typedef struct
{
#ifndef ETHER_ADDR_LEN
#define ETHER_ADDR_LEN 6
#endif
    uint8_t  ether_dhost[ETHER_ADDR_LEN]; /* destination ethernet address */
    uint8_t  ether_shost[ETHER_ADDR_LEN]; /* source ethernet address */
    uint16_t TPID;                        /* 0x8100 */
    uint16_t vlan_header;                 /* vlan header: PCP(3 bits), CFI (1 bits), VID (12 bits) */
    uint16_t ether_type;                  /* 0x66ab */
    uint8_t  unused[2];
    uint64_t tx_timestamp;                /* timestamp when packet is sent before PHY */
    uint64_t rx_timestamp;                /* timestamp when packet is received after PHY */
    uint16_t seq_id;                      /* sequence id for this data stream traffic */
    uint32_t pkt_id;                      /* packet id for this packet in the seq_id data stream */
} __attribute__ ((packed)) ethernet_packet_vlan;

typedef struct
{
#ifndef ETHER_ADDR_LEN
#define ETHER_ADDR_LEN 6
#endif
    uint8_t  ether_dhost[ETHER_ADDR_LEN]; /* destination ethernet address */
    uint8_t  ether_shost[ETHER_ADDR_LEN]; /* source ethernet address */
    uint16_t ether_type;                  /* 0x66ab */
    uint8_t  unused[2];
    uint64_t tx_timestamp;                /* timestamp when packet is sent before PHY */
    uint64_t rx_timestamp;                /* timestamp when packet is received after PHY */
    uint16_t seq_id;                      /* sequence id for this data stream traffic */
    uint32_t pkt_id;                      /* packet id for this packet in the seq_id data stream */
} __attribute__ ((packed)) ethernet_packet;

// if enable vlan is 0, then TPID and vlan_header are undefined 
//      and won't be used in packet generation.
// ** IMPORTANT: in order to accomadate AXI-S protocol, TPID, vlan_header should swap byte order before store. **
typedef struct
{
#ifndef ETHER_ADDR_LEN
#define ETHER_ADDR_LEN 6
#endif
    uint8_t  ether_dhost[ETHER_ADDR_LEN]; /* destination ethernet address */
    uint8_t  ether_shost[ETHER_ADDR_LEN]; /* source ethernet address */
    uint16_t TPID;                        /* 0x8100 */
    uint16_t vlan_header;                 /* vlan header: PCP(3 bits), CFI (1 bits), VID (12 bits) */
} __attribute__ ((packed)) ethernet_packet_hdr; // this should be 16byte size exactly

typedef struct
{
    ethernet_packet_hdr hdr;
    uint16_t seq_id;
    uint16_t pkt_number_sent;
    uint32_t pkt_id_start;
    uint32_t pkt_id_update;
    uint64_t tx_offset;
} __attribute__ ((packed)) sequence_content;


/* Init UIO device and return base_ptr address */
int pkt_gen_init();

/**
 * @brief Start updating schedule table for packet generation
 * 
 * @param global_period_ns set global period to 2^x ns
 * @return int 
 */
int start_pkt_gen_config(uint64_t global_period_ns);

/**
 * @brief Finish updating schedule table for packet generation
 * 
 * @return int 
 */
int finish_pkt_gen_config();

/**
 * @brief Set the pkt gen slot object
 * 
 * @param slot_id 0~31, indicate a slot in pkt_gen IP core
 *      IMPORTANT: tx_offset for each slot id should be monotonic increasing
 * @param seq_id sequence ID that uniquely identify a stream
 *              To further utilize this field, it may be {job_id: 8bit, flow_id: 8bit}
 * @param pkt_number number of packets in one sent, should be 1
 * @param pkt_id_start start of pkt_id
 * @param pkt_id_update update of next pkt_id
 * @param tx_offset transmission time inside a period, in ns
 * @param src_mac 6Byte array
 * @param dest_mac 6Byte array
 * @return int 
 */
int set_pkt_gen_slot (int slot_id, uint16_t seq_id, uint16_t pkt_number, uint32_t pkt_id_start, 
        uint32_t pkt_id_update, int64_t tx_offset, uint8_t *src_mac, uint8_t *dest_mac);


/* Check if a packet is critical frame (generated by pkt_gen module) 
* ethertype should be 0x66ab
*/
int is_critical_frame (uint8_t * buf_ptr);

/* Print neccessary information for critical frame 
*/
int print_critical_frame (uint8_t *buf_ptr);

typedef struct 
{
    uint32_t min_pkt_id;
    uint32_t max_pkt_id;
    uint32_t cur_pkt_id;
    uint32_t num_pkt_recvd;
    int64_t *latency_list;
} critical_seq_log;


/* Log the seq_id, pkt_id, transmission latency information for each sequence
 * Calculate mean, variance, drop rate ... every SEQ_REPORT_NUM packets
 * Output to a file
*/
void process_critical_frame (uint8_t *buf);

int pkt_gen_test();

#endif
